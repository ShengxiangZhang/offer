## 回溯模板
```C++
void backtraking(参数){
    if(终止条件)
        存放结果;
        返回；
    
    for(横向，层内移动){
        处理节点;
        backtraking(参数)递归;
        回溯，撤销处理结果;
    }
}
```
## 1.组合问题
n个数里，找出k个数的组合。
## 2.切割问题

## 3 排列问题

### 3.1 给定一个不含重复数字的数组，求排列
例如：给定数组[1,2,3]，求全排列。
这类题稍微简单，需要注意的点是，在求排列时，需要注意，上一层已经选取的元素在下面的层中不要重复选取，也就是不能出现类似[1,1,1],[1,1,2]类似的情况。  
解决方法时定义一个used数组，记录上一层使用了哪些元素，在递归时传递给下一层，下一层在循环时，遇到上一层已经使用过的元素就直接跳过

### 3.2 给定一个含重复数字的数组，求全排列
例如，给定数组[1,1,2],求全排列。这类题目比3.1要复杂一些。  
如果按照3.1的思路来解这道题，结果会出现不止一个[1,1,2]。思考一下，按照3.1的思路，情况1：当第一层递归选定第一个元素1，第二层递归时选定第二个元素1，第三层递归选定元素2，得到[1,1,2]；情况2:当第一层递归选定第二个元素1时，第二层递归选定第一个元素1，第三层递归选定元素2，也得到[1,1,2],所以最终结果会出现重复的集合。  
**因此，需要进行去重。** 首先，我们要明确为什么会出现这样的重复？是因为，在每一个层中，我们重复选择了某一元素，还是举上面的例子，可以发现，在情况1和情况2中，我们在第一层递归中两次选择了元素1（虽然是在不同位置），导致了集合的重复。  
解决方法：可以使用一个set或者哈希表，存储一层中已经使用过的元素，如果遍历到已经使用过的元素，直接跳过。
